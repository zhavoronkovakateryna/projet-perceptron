# -*- coding: utf-8 -*-
#################################### Import ####################################
import numpy as np
import matplotlib.pyplot as plt

#################################### Main ######################################       
def créer_mlp(nb_neurone_par_couche, fonction_couche, theta_neurone_couche, delta=0, data=[(),()])->dict:
    """
    Créer un réseau MLP de <len(nb_neurone_couche)> couches, avec <nb_neurone_couche[i]> neurones 
    à la couche i muni de la fonction d'activation <fonction_couche[i]>

    Parameters
    ----------
    nb_neurone_couche : list
        de la forme [nb_neurone_couche_1,nb_neurone_couche_2,..].
    fonction_couche : list
        de la forme [fonction_couche_1,fonction_couche_2,..].
    theta_neurone_couche : list
        de la forme [ [ [N_1_1],..], [[N_2_1],..], .. ].

    Returns
    -------
    dict
        Réseau MLP.
    """
    reseaux = {}
    for i in range(len(nb_neurone_par_couche)):
        for j in range(nb_neurone_par_couche[i]):
            nom = "N_" + f"{i+1}_{j+1}"
            reseaux[nom] = {
                "position": (i+1, j+1),
                "fonction": fonction_couche[i],
                "dérivé_fonction" : ......,
                "theta": np.array(theta_neurone_couche[i][j], float),
                delta: 0 }
    reseaux["data"] = data
    reseaux["couche"]=nb_neurone_par_couche
    reseaux["Gi_prim(z)"]=[[0 for i in range(len(nb_neurone_par_couche))] for j in range(nb_neurone_par_couche[i])]
    return reseaux

def affichage(reseaux):
    for i in reseaux.keys():
        if i!="data":
            print(f'|nom : {i} __ paramètre : {reseaux[i]["theta"]}|')
    return None        

def data_entry(reseaux)->None:
    """Fonction demandant et affecte le array au perceptron <self>"""
    data = eval(input('Transmettez vos données: '))
    reseaux["data"] = np.array(data)

def z(reseaux, nom, Xi):
    """
    Calcule zn = w·xn + b.
    """
    w = reseaux[nom]["theta"][:-1]
    b = reseaux[nom]["theta"][-1]
    xn = np.array(Xi)
    return np.dot(w, xn) + b

def Z_vect(reseaux, couche, Xi):
    Z = np.array([
        z(reseaux, nom, Xi)
        for nom in reseaux.keys()
        if nom != "data" and reseaux[nom]["position"][0] == couche
    ])
    return np.array(Z)

def propa_avant(Z, couche, reseaux):
    return reseaux[f"N_{couche}_1"]["fonction"](Z)

def propa_globale(Z, reseaux, nb_de_couches):
    for i in range(nb_de_couches):
        Z = Z_vect(reseaux, i+1, Z)
        G = propa_avant(Z, i+1, reseaux)
        Z = G
    return np.array(G)

#peut etre faire pour les dérivés et stockétoutes les données

def delta_fin(couche, Z, reseaux):
    delta = np.array([derivé_sigmoid(Z)])
    L = sum(
        propa_globale(reseaux["data"][i][0], reseaux, couche) - reseaux["data"][i][1]
        for i in range(len(reseaux["data"]))
    ) * 1/len(reseaux["data"])
    delta = delta * L
    return np.array(delta)

def propa_arrière(couche, reseaux):
    L = [ sum(reseaux[f"N_{couche+1}_{j}"]["delta"] * reseaux[f"N_{couche}_{i}"]["theta"][j] * reseaux["Gi_prim(z)"][i][j] for j in range(len(reseaux[f"N_{couche+1}_1"]["theta"]) - 1))
        for i in range(len(reseaux[f"N_{couche}_1"]["theta"]) - 1) ]            #reseaux[f"N_{couche}_{i}"]["theta"][j] = wij ^ (couche)
    return np.array(L)


def calcule_derive_globale(reseaux,X):
    """
    Met à jour les dérivées du réseaux dans reseaux['Gi_prim(z)']
    
    Parameters
    ----------
    reseaux : dict
        DESCRIPTION.
    X : array
        dans les datas.

    Returns
    -------
    None.
    """
    derivé=[[0 for j in range(reseaux["couche"][i]) ] for i in range(len(reseaux["couche"]))]
    for i in range(len(reseaux["couche"])):
        for j in range(reseaux["couche"][i]):
            derivé[i][j]=reseaux["N_{i+1}_1"]["dérivé_fonction"](z(reseaux, "N_{i+1}_{j}",))

    reseaux["Gi_prim(z)"]=derivé
    return None


sigmoid = lambda x: 1/(1+np.exp(-x))
derivé_sigmoid = lambda x: sigmoid(x)*(1-sigmoid(x))
